# php_binary_search_in_file
Бинарный поиск по файлу с ключами

### Задача
Написать функцию, реализующую бинарный поиск значения по ключу в
текстовом файле.
Аргументы: имя файла, значение ключа
Результат: если найдено: значение, соответствующее ключу, если не найдено: undef
Исходные данные и требования к реализации:
1. Объем используемой памяти не должен зависеть от размера файла, только от максимального размера
записи.
2. Формат файла: ключ1\tзначение1\x0Aключ2\tзначение2\x0A...ключN\tзначениеN\x0A Где: \x0A -
разделитель записей (код ASCII: 0Ah) \t - разделитель ключа и значения (табуляция, код ASCII: 09h) Символы
разделителей гарантированно не могут встречаться в ключах или значениях. Записи упорядочены по ключу в
лексикографическом порядке с учетом регистра. Все ключи гарантированно уникальные.
3. Ограничений на длину ключа или значения нет.
Функция на файле размером 10Гб с записями длиной до 4000 байт должна отрабатывать любой запрос менее
чем за 5 секунд.

### Решение
Функция, выполняющая бинарный поиск - в файле [binary.php](./binary.php)

Замечания:
- на файле с параметрами из п.3 функция не проверялась за неимением оного. Однако, так как бинарный поиск достаточно экономичен, полагаю что требование по скорости будет выполнено. Также, как и предложено в задаче, файл не читается целиком в память, поэтому не вижу и ограничений по размеру файла.
- для демонстрации работы функции приложен файл  [binary_demo.php](./binary_demo.php) использующий эту же функцию и файл dict_keyed.txt с небольшим количеством ключей, упорядоченных по принципам из пункта 2. Будучи запущенным, демо-файл производит бинарный поиск по этому файлу и комментирует ход процесса на соответствующей странице. Поисковый ключ и путь к файлу-словарю захардкожены. 
- это тестовое задание, в реальности, возможно, бинарный поиск по файлу не всегда оправдан, т.к. дисковые операции могут быть оптимизированы на низком уровне для последовательного доступа.


